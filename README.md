![logo](https://github.com/Plasma-Paris/LifetimeConsistencyCheck/raw/master/documentation/ReadMe_Resources/logo.png)

# LifetimeConsistencyCheck

Add extensions that allow consistency lifetime check for services registered into Microsoft's native dependency injection system for .NET Core 2.0

## Why we need this ?

Logically, a Scoped or Transient dependency can not be injected into a Singleton dependency: the lifetime of a dependency injected into a service's constructor can not be shorter than the lifetime of the service itself.

Unlike other dependency injection systems, the native microsoft system does not check this behavior. A Scoped dependency injected into a Singleton will behave as if it was itself a Singleton, without the developer being informed.

This can create unwanted side effects, especially in a multi-threaded applications.

This behavior is clearly described in the Microsoft documentation:
![log_warning](https://github.com/Plasma-Paris/LifetimeConsistencyCheck/raw/master/documentation/ReadMe_Resources/doc_warning.png)

Source : https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-2.0

## Installing / Getting started

Simply reference the librairies into your project, or use NuGet :

```shell
Install-Package LifetimeConsistencyCheck
```

https://www.nuget.org/packages/LifetimeConsistencyCheck

## Usage

```c#
public class Startup
{
	// …
	public IServiceProvider ConfigureServices(IServiceCollection services)
	{
		// …
		services.AddSingleton<IMyService1, MyService1>();
		services.AddScoped<IMyService2, MyService2>();
		// …

		services.CheckLifetimeConsistency();
		return services.BuildServiceProviderWithLifetimeConsistencyCheck();
	}
}
```

### Check at application start

```c#
services.CheckLifetimeConsistency();
```
The first method checks the consistency of the lifetime of all the services that were register (as far as possible) as soon as the method is executed, which makes it possible to be informed as soon as possible if there is an inconsistency.

### Check at service resolving

```c#
services.BuildServiceProviderWithLifetimeConsistencyCheck();
```
The second method checks the consistency of each service regarding its dependencies at its resolving.

### Why two different methods ?

Ideally we would have wanted to use only the first method, but it is not always possible. If a service is register as follows:

```c#
services.AddSingleton<IMyService>((c) => new MyService(c.GetService<IMyService2>());
```

It is possible to know the exact implementation of the service only by running the factory that creates it. For avoid undesirable side effects, check of the consistency of this kind of service is done only when the dependency injection system resolves the service.

### Parameters

#### checkFactoriesOnly Parameter

The `BuildServiceProviderWithLifetimeConsistencyCheck` has a `checkFactoriesOnly`, because if the `CheckLifetimeConsistency` is call at startup, services registered with an other method than with a factory are already tested, so it is not necesseray to test them again during their resolving.

#### ignoreMicrosoftInternalErrors Parameter

Even Microsoft do the mistake of using Transient services in Singleton services (Exemple : `ICompositeMetadataDetailsProvider` is a Transient service used in the `DefaultModelMetadataProvider` Singleton service, same for `IRazorPageFactoryProvider` and `PageActionInvokerProvider`, and a few others). 
This parameter allow to ignore errors generated by services in the Microsoft or System namespace.

## To Do

* **PUSH SOURCES FOR THE SECOND METHOD** :-)
* Optimze the check at resolve
* Make the error message more detailed when check at resolve
* …

## Contributing

If you'd like to contribute, please fork the repository and use a feature branch. Pull requests are welcome.

## Licensing

The code in this project is licensed under MIT license.